#-----------------------------------------------
＃画像処理
#-----------------------------------------------
//三色の平均取った価を三色全部に代入する。
●(xywhを)画像グレイスケール
　色データとは変数＝xywhの色データ取得。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　色平均とは変数＝(色データ[C] + 色データ[C+1] + 色データ[C+2])/3。
　　　色データ[C]＝色平均。色データ[C+1]＝色平均。色データ[C+2]＝色平均。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

//セピアという名称ですが、グレイスケール化したものに特定の色でフィルタ掛ける感じ。
//セピア調になるのは「#FFCC99」あたり？　Bの価を下げるともっと黄ばんだ感じが出る。
//rgbは[R,G,B]または「#RRGGBB」
●(rgbでxywhを)画像セピア
　もし、（rgbの1だけ文字左部分）＝「#」ならば、rgb＝rgbのRGB分解。
　色データとは変数＝xywhの色データ取得。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　色平均とは変数＝(色データ[C] + 色データ[C+1] + 色データ[C+2])/3。
　　　色データ[C]＝色平均*rgb[0]/255。色データ[C+1]＝色平均*rgb[1]/255。色データ[C+2]＝色平均*rgb[2]/255。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

//閾値は(0-255)。二値化。
●(閾値でxywhを)画像モノクロ
　もし、閾値＜０ならば、閾値＝０。
　もし、閾値＞２５５ならば、閾値＝２５５。
　色データとは変数＝xywhの色データ取得。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　色平均とは変数＝(色データ[C] + 色データ[C+1] + 色データ[C+2])/3。
　　　もし、閾値＜色平均ならば、
　　　　色データ[C]＝255。色データ[C+1]＝255。色データ[C+2]＝255。
　　　違えば、
　　　　色データ[C]＝0。色データ[C+1]＝0。色データ[C+2]＝0。
　　　ここまで。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

//反転
●(xywhを)画像ネガポジ
　色データとは変数＝xywhの色データ取得。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　色データ[C]＝255-色データ[C]。色データ[C+1]＝255-色データ[C+1]。色データ[C+2]＝255-色データ[C+2]。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

#-----------------------------------------------
＃明度、色相、彩度
#-----------------------------------------------
//レベルは(-100から100)。ｖ１とは引数が違います。
●(レベルでxywhを)画像明度補正
　色データとは変数＝xywhの色データ取得。
　補正値とは変数。
　もし、((レベルの符号)＝-1)ならば、補正値＝「#000000」。
　違えば、補正値＝「#FFFFFF」
　レベルはレベルの絶対値。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　結果とは変数＝レベルで[[色データ[C]],[色データ[C+1]],[色データ[C+2]]]と補正値の混色計算。
　　　色データ[C]＝結果[0]。色データ[C+1]＝結果[1]。色データ[C+2]＝結果[2]。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

//レベルは(-100から100)。ｖ１には無い。
●(レベルでxywhを)画像彩度補正
　色データとは変数＝xywhの色データ取得。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　HSL色とは変数＝[色データ[C],色データ[C+1],色データ[C+2]]をHSL変換。
　　　HSL色[1]＝HSL色[1]+レベル。
　　　もし、HSL色[1]＞100ならば、HSL色[1]＝100。
　　　もし、HSL色[1]＜0ならば、HSL色[1]＝0。
　　　RGB色とは変数＝HSL色をRGB変換。
　　　色データ[C]＝RGB色[0]。色データ[C+1]＝RGB色[1]。色データ[C+2]＝RGB色[2]。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

//レベルは(-180から180)。ｖ１には無い。
●(レベルでxywhを)画像色相補正
　色データとは変数＝xywhの色データ取得。
　もし、(レベル＜-180)ならば、レベル＝-180。
　もし、(レベル＞180)ならば、レベル＝180。
　(色データの要素数)/4回
　　　Cとは変数＝(回数-1)*4。
　　　HSL色とは変数＝[色データ[C],色データ[C+1],色データ[C+2]]をHSL変換。
　　　HSL色[0]＝HSL色[0]+レベル。
　　　もし、(HSL色[0]＜0)ならば、HSL色[0]＝HSL色[0]+360。
　　　もし、(HSL色[0]≧360)ならば、HSL色[0]＝HSL色[0]-360。
　　　RGB色とは変数＝HSL色をRGB変換。
　　　色データ[C]＝RGB色[0]。色データ[C+1]＝RGB色[1]。色データ[C+2]＝RGB色[2]。
　ここまで。
　xywhを色データで画像処理反映。
ここまで。

#-----------------------------------------------
＃グラデーションの計算
#-----------------------------------------------
# 混色（色等比計算）
//色1、色2は、[R,G,B]または「#RRGGBB」。
//Aが大きいほど色2に近付く。(A=0～100。0=色1、100=色2となる)
●(Aで色1と色2の)混色計算
　　Rとは変数。Gとは変数。Bとは変数。R1とは変数。G1とは変数。B1とは変数。R2とは変数。G2とは変数。B2とは変数。
　　もし、(色1の1だけ文字左部分)＝「#」ならば、色1＝色1のRGB分解。
　　R1=色1[0]。G1=色1[1]。B1=色1[2]
　　もし、(色2の1だけ文字左部分)＝「#」ならば、色2＝色2のRGB分解。
　　R2=色2[0]。G2=色2[1]。B2=色2[2]。
　　R=(R2-R1)*A/100+R1を整数変換。
　　G=(G2-G1)*A/100+G1を整数変換。
　　B=(B2-B1)*A/100+B1を整数変換。
　　[R,G,B]で戻る。
ここまで。

# 色等差計算
//元色は、[R,G,B]または「#RRGGBB」。
//Aが小さいと濃く、大きいと明るくなる。(A=0～100。50=元色となる)
//元色が暗かったり明るかったりすると、0に近い値が黒になったり100に近い値が白になったりする。
//MaxがFF、Minが00になる色は、全部同じ色。
●(Aで元色の)色等差計算
　　Maxとは変数。Minとは変数。Rとは変数。Gとは変数。Bとは変数。R1とは変数。G1とは変数。B1とは変数。
　　もし、(元色の1だけ文字左部分)＝「#」ならば、元色＝元色のRGB分解。
　　R1=元色[0]。G1=元色[1]。B1=元色[2]。
　　Max＝元色の配列最大値。Min＝元色の配列最小値。
　　R=(255-Max+Min)*(A-50)/100+R1を整数変換。
　　G=(255-Max+Min)*(A-50)/100+G1を整数変換。
　　B=(255-Max+Min)*(A-50)/100+B1を整数変換。
　　もし、R＞255ならば、R=255。もし、R＜0ならば、R=0。
　　もし、G＞255ならば、G=255。もし、G＜0ならば、G=0。
　　もし、B＞255ならば、B=255。もし、B＜0ならば、B=0。
　　[R,G,B]で戻る。
ここまで。

#-----------------------------------------------
＃RGB⇔HSL
#-----------------------------------------------
# RGB[R,G,B]→HSL[H,S,L]
●(rgbを)HSL変換
　　Hとは変数。Sとは変数。Lとは変数。
　　Rとは変数＝rgb[0]。Gとは変数＝rgb[1]。Bとは変数＝rgb[2]。
　　Maxとは変数＝rgbの配列最大値。Minとは変数＝rgbの配列最小値。
　　もし、(R=G)かつ(G=B)ならば、H=0。
　　違えば、もし、Max＝Rならば、H=60*((G-B)/(Max-Min))。
　　違えば、もし、Max＝Gならば、H=60*((B-R)/(Max-Min))+120。
　　違えば、もし、Max＝Bならば、H=60*((R-G)/(Max-Min))+240。
　　もし、H＜0ならば、H=H+360。
　　H=Hを四捨五入。
　　L=(Max+Min)/2。
　　もし、(Max=Min)ならば、S=0。
　　違えば、もし、L＜128ならば、S=(Max-Min)/(Max+Min)
　　違えば、S=(Max-Min)/(510-Max-Min)
　　S=S*100を1で小数点四捨五入。
　　L=L/255*100を1で小数点四捨五入。
　　[H,S,L]で戻る。
ここまで。

# HSL[H,S,L]→RGB[R,G,B]
●(hslを)RGB変換
　　Rとは変数。Gとは変数。Bとは変数。Maxとは変数。Minとは変数。
　　Hとは変数＝hsl[0]。Sとは変数＝hsl[1]。Lとは変数＝hsl[2]。
　　もし、L＜50ならば、
　　　　Max=2.55*(L+L*(S/100))。Min=2.55*(L-L*(S/100))
　　違えば、
　　　　Max=2.55*(L+(100-L)*(S/100))。Min=2.55*(L-(100-L)*(S/100))
　　ここまで。
　　もし、(0≦H）かつ（H＜60）ならば、
　　　R=Max。G=(H/60)*(Max-Min)+Min。B=Min。
　　違えば、もし、(60≦H）かつ（H＜120）ならば、
　　　R=((120-H)/60)*(Max-Min)+Min。G=Max。B=Min。
　　違えば、もし、(120≦H）かつ（H＜180）ならば、
　　　R=Min。G=Max。B=((H-120)/60)*(Max-Min)+Min。
　　違えば、もし、(180≦H）かつ（H＜240）ならば、
　　　R=Min。G=((240-H)/60)*(Max-Min)+Min。B=Max。
　　違えば、もし、(240≦H）かつ（H＜300）ならば、
　　　R=((H-240)/60)*(Max-Min)+Min。G=Min。B=Max。
　　違えば、もし、(300≦H）かつ（H＜360）ならば、
　　　R=Max。G=Min。B=((360-H)/60)*(Max-Min)+Min。
　　ここまで。
　　R=Rを四捨五入。G=Gを四捨五入。B=Bを四捨五入。
　　[R,G,B]で戻る。
ここまで。

#-----------------------------------------------
＃「#RRGGBB」→[RGB]
#-----------------------------------------------
// HTMLの16進カラーコード(#RRGGBB)を256色の配列[R,G,B]に分解。
●(色を|色の)RGB分解
　分色とは変数。分色＝空配列。
　色＝色の「#」を「0x」に置換。
　色＝色を整数変換。
　数を２から０まで繰り返す
　　分色[数]＝色%256。
　　色＝(色-分色[数])/256
　ここまで。
　分色で戻る。
ここまで。

#-----------------------------------------------
＃色データの取得と設定
#-----------------------------------------------
●(xywhの|xywhを)色データ取得
「sys.__ctx.getImageData({xywh[0]},{xywh[1]},{xywh[2]},{xywh[3]}).data」をJS実行。
ここまで。
●(xywhを色データで|xywhに)画像処理反映
「(function (color){波カッコ}
const img = sys.__ctx.getImageData({xywh[0]}, {xywh[1]}, {xywh[2]},{xywh[3]});
let data = img.data;
for (let i=0; i<data.length;i++){波カッコ}data[i]=color[i]{波カッコ閉じ}
sys.__ctx.putImageData(img,{xywh[0]}, {xywh[1]});
{波カッコ閉じ})」を[色データ]でJS関数実行。
ここまで。
#-----------------------------------------------